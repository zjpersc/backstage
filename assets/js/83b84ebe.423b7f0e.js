/*! For license information please see 83b84ebe.423b7f0e.js.LICENSE.txt */
"use strict";(self.webpackChunkbackstage_microsite=self.webpackChunkbackstage_microsite||[]).push([[870425],{603905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var a=n(667294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var p=a.createContext({}),s=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},u=function(e){var t=s(e.components);return a.createElement(p.Provider,{value:t},e.children)},d="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,p=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=s(n),m=o,h=d["".concat(p,".").concat(m)]||d[m]||c[m]||i;return n?a.createElement(h,r(r({ref:t},u),{},{components:n})):a.createElement(h,r({ref:t},u))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=m;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l[d]="string"==typeof e?e:o,r[1]=l;for(var s=2;s<i;s++)r[s]=n[s];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},916008:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>c,frontMatter:()=>r,metadata:()=>p,toc:()=>u});n(827378);var a=n(603905);function o(){return o=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},o.apply(this,arguments)}function i(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}const r={id:"composability",title:"Composability System",description:"Documentation for the Backstage plugin composability APIs."},l=void 0,p={unversionedId:"plugins/composability",id:"plugins/composability",title:"Composability System",description:"Documentation for the Backstage plugin composability APIs.",source:"@site/../docs/plugins/composability.md",sourceDirName:"plugins",slug:"/plugins/composability",permalink:"/docs/plugins/composability",draft:!1,editUrl:"https://github.com/backstage/backstage/edit/master/docs/../docs/plugins/composability.md",tags:[],version:"current",frontMatter:{id:"composability",title:"Composability System",description:"Documentation for the Backstage plugin composability APIs."},sidebar:"docs",previous:{title:"Integrating Search into a plugin",permalink:"/docs/plugins/integrating-search-into-plugins"},next:{title:"Customization (Experimental)",permalink:"/docs/plugins/customization"}},s={},u=[{value:"Summary",id:"summary",level:2},{value:"Concepts",id:"concepts",level:2},{value:"Component Data",id:"component-data",level:3},{value:"Extensions",id:"extensions",level:3},{value:"Extensions from a Plugin&#39;s Point of View",id:"extensions-from-a-plugins-point-of-view",level:3},{value:"Using Extensions in an App",id:"using-extensions-in-an-app",level:3},{value:"Naming Patterns",id:"naming-patterns",level:3},{value:"Routing System",id:"routing-system",level:3},{value:"Binding External Routes in the App",id:"binding-external-routes-in-the-app",level:3},{value:"Optional External Routes",id:"optional-external-routes",level:3},{value:"Parameterized Routes",id:"parameterized-routes",level:3},{value:"Subroutes",id:"subroutes",level:3},{value:"Catalog Components",id:"catalog-components",level:3},{value:"Porting Existing Plugins",id:"porting-existing-plugins",level:2},{value:"Naming Patterns",id:"naming-patterns-1",level:3}],d={toc:u};function c(e){var{components:t}=e,n=i(e,["components"]);return(0,a.kt)("wrapper",o({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h2",o({},{id:"summary"}),"Summary"),(0,a.kt)("p",null,"This page describes the composability system that helps bring together content\nfrom a multitude of plugins into one Backstage application."),(0,a.kt)("p",null,"The core principle of the composability system is that plugins should have clear\nboundaries and connections. It should isolate crashes within a plugin, but allow\nnavigation between them. It should allow for plugins to be loaded only when\nneeded, and enable plugins to provide extension points for other plugins to\nbuild upon. The composability system is also built with an app-first mindset,\nprioritizing simplicity and clarity in the app over that in the plugins and core\nAPIs."),(0,a.kt)("p",null,"The composability system isn't a single API surface. It is a collection of\npatterns, primitives, and APIs. At the core is the concept of ",(0,a.kt)("strong",{parentName:"p"},"extensions"),",\nwhich are exported by plugins for use in the app. There is also a primitive\ncalled component data, which helps keep the structure of the app more\ndeclarative. There are also ",(0,a.kt)("inlineCode",{parentName:"p"},"RouteRef"),"s that help route between pages in a\nflexible way, which is especially important when bringing together different\nopen source plugins."),(0,a.kt)("h2",o({},{id:"concepts"}),"Concepts"),(0,a.kt)("p",null,"This section is a brief look into all the concepts that help support the\ncomposability system."),(0,a.kt)("h3",o({},{id:"component-data"}),"Component Data"),(0,a.kt)("p",null,"Component data is a composability primitive that is introduced as a way to\nprovide a new data dimension for React components. Data is attached to React\ncomponents using a key, and is then readable from any JSX elements created with\nthose components, using the same key, as illustrated by the following example:"),(0,a.kt)("pre",null,(0,a.kt)("code",o({parentName:"pre"},{className:"language-tsx"}),"const MyComponent = () => <h1>This is my component</h1>;\nattachComponentData(MyComponent, 'my.data', 5);\n\nconst element = <MyComponent />;\nconst myData = getComponentData(element, 'my.data');\n// myData === 5\n")),(0,a.kt)("p",null,"The purpose of component data is to provide a method for embedding data that can\nbe inspected before rendering elements. Element inspection is a pattern that is\nquite common among React libraries, and used for example by ",(0,a.kt)("inlineCode",{parentName:"p"},"react-router")," and\n",(0,a.kt)("inlineCode",{parentName:"p"},"material-ui")," to discover properties of the child elements before rendering.\nAlthough in those libraries only the element type and props are typically\ninspected, while our component data adds more structured access and simplifies\nevolution by allowing for multiple different versions of a piece of data to be\nused and interpreted at once."),(0,a.kt)("p",null,"One of the use-cases for component data is to support route and plugin discovery\nthrough elements in the app. Through this we allow for the React element tree in\nthe app to be the source of truth, both for which plugins are used, as well as\nall top-level plugin routes in the app. The use of component data is not limited\nto these use-cases though, as it can be used as a primitive to create new\nabstractions as well."),(0,a.kt)("h3",o({},{id:"extensions"}),"Extensions"),(0,a.kt)("p",null,"Extensions are what plugins export for use in an app. Most typically they are\nReact components, but in practice they can be any kind of JavaScript value. They\nare created using ",(0,a.kt)("inlineCode",{parentName:"p"},"create*Extension")," functions, and wrapped with\n",(0,a.kt)("inlineCode",{parentName:"p"},"plugin.provide()")," in order to create the actual exported extension."),(0,a.kt)("p",null,"The extension type is a simple one:"),(0,a.kt)("pre",null,(0,a.kt)("code",o({parentName:"pre"},{className:"language-ts"}),"export type Extension<T> = {\n  expose(plugin: BackstagePlugin): T;\n};\n")),(0,a.kt)("p",null,"The power of extensions comes from the ability of various actors to hook into\ntheir usage. The creation and plugin wrapping is controlled by whoever owns the\ncreation function, the Backstage core is able to hook into the process of\nexposing the extension outside the plugin, and in the end the app controls the\nusage of the extension."),(0,a.kt)("p",null,"The Backstage core API currently provides two different types of extension\ncreators, ",(0,a.kt)("inlineCode",{parentName:"p"},"createComponentExtension"),", and ",(0,a.kt)("inlineCode",{parentName:"p"},"createRoutableExtension"),". Component\nextensions are plain React component with no particular requirements, for\nexample a card for an entity overview page. The component will be exported more\nor less as is, but is wrapped to provide things like an error boundary, lazy\nloading, and a plugin context."),(0,a.kt)("p",null,"Routable extensions build on top of component extensions and are used for any\ncomponent that should be rendered at a specific route path, such as top-level\npages or entity page tab content. When creating a routable extension you need to\nsupply a ",(0,a.kt)("inlineCode",{parentName:"p"},"RouteRef")," as ",(0,a.kt)("inlineCode",{parentName:"p"},"mountPoint"),". The mount point will be the handle of the\ncomponent for the outside world, and is used by other components and plugins\nthat wish to link to the routable component."),(0,a.kt)("p",null,"As of now there are only two extension creation functions in the core library,\nbut more may be added in the future. There are also some plugins that provide\nways to extend functionality through their own extensions, like\n",(0,a.kt)("inlineCode",{parentName:"p"},"createScaffolderFieldExtension")," from ",(0,a.kt)("inlineCode",{parentName:"p"},"@backstage/plugin-scaffolder"),". Extensions\nare also not tied to React, and can both be used to model generic JavaScript\nconcepts, as well as potentially bridge to rendering libraries and web\nframeworks other than React."),(0,a.kt)("h3",o({},{id:"extensions-from-a-plugins-point-of-view"}),"Extensions from a Plugin's Point of View"),(0,a.kt)("p",null,"Extensions are one of the primary methods to traverse the plugin boundary, and\nthe way that plugins provide concrete content for use within an app. They\nreplace existing component export concepts such as ",(0,a.kt)("inlineCode",{parentName:"p"},"Router")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"*Card"),"s for\ndisplay on entity overview pages."),(0,a.kt)("p",null,"It is recommended to create the exported extensions either in the top-level\n",(0,a.kt)("inlineCode",{parentName:"p"},"plugin.ts")," file, or in a dedicated ",(0,a.kt)("inlineCode",{parentName:"p"},"extensions.ts")," (or ",(0,a.kt)("inlineCode",{parentName:"p"},".tsx"),") file. That file\nshould not contain the bulk of the implementation though, and in fact, if the\nextension is a React component it is recommended to lazy-load the actual\ncomponent. Component extensions support lazy loading out of the box using the\n",(0,a.kt)("inlineCode",{parentName:"p"},"lazy")," component declaration, for example:"),(0,a.kt)("pre",null,(0,a.kt)("code",o({parentName:"pre"},{className:"language-ts"}),"export const EntityFooCard = plugin.provide(\n  createComponentExtension({\n    component: {\n      lazy: () => import('./components/FooCard').then(m => m.FooCard),\n    },\n  }),\n);\n")),(0,a.kt)("p",null,"Routable extensions even enforce lazy loading, as it is the only way to provide\na component:"),(0,a.kt)("pre",null,(0,a.kt)("code",o({parentName:"pre"},{className:"language-ts"}),"export const FooPage = plugin.provide(\n  createRoutableExtension({\n    name: 'FooPage',\n    component: () => import('./components/FooPage').then(m => m.FooPage),\n    mountPoint: fooPageRouteRef,\n  }),\n);\n")),(0,a.kt)("h3",o({},{id:"using-extensions-in-an-app"}),"Using Extensions in an App"),(0,a.kt)("p",null,"Right now all extensions are modelled as React components. The usage of these\nextension is like regular usage of any React components, with one important\ndifference. Extensions must all be part of a single React element tree spanning\nfrom the root ",(0,a.kt)("inlineCode",{parentName:"p"},"AppProvider"),"."),(0,a.kt)("p",null,"For example, the following app code does ",(0,a.kt)("strong",{parentName:"p"},"NOT")," work:"),(0,a.kt)("pre",null,(0,a.kt)("code",o({parentName:"pre"},{className:"language-tsx"}),'const AppRoutes = () => (\n  <Routes>\n    <Route path="/foo" element={<FooPage />} />\n    <Route path="/bar" element={<BarPage />} />\n  </Routes>\n);\n\nconst App = () => (\n  <AppProvider>\n    <AppRouter>\n      <Root>\n        <AppRoutes />\n      </Root>\n    </AppRouter>\n  </AppProvider>\n);\n')),(0,a.kt)("p",null,"But in this case it is simple to fix! Simply be sure to not create any\nintermediate components in the app, for example like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",o({parentName:"pre"},{className:"language-tsx"}),'const appRoutes = (\n  <Routes>\n    <Route path="/foo" element={<FooPage />} />\n    <Route path="/bar" element={<BarPage />} />\n  </Routes>\n);\n\nconst App = () => (\n  <AppProvider>\n    <AppRouter>\n      <Root>{appRoutes}</Root>\n    </AppRouter>\n  </AppProvider>\n);\n')),(0,a.kt)("h3",o({},{id:"naming-patterns"}),"Naming Patterns"),(0,a.kt)("p",null,"There are a couple of naming patterns to adhere to as you build plugins, which\nhelps clarify the intent and usage of the exports."),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",o({parentName:"tr"},{align:null}),"Description"),(0,a.kt)("th",o({parentName:"tr"},{align:null}),"Pattern"),(0,a.kt)("th",o({parentName:"tr"},{align:null}),"Examples"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",o({parentName:"tr"},{align:null}),"Top-level Pages"),(0,a.kt)("td",o({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"\\*Page")),(0,a.kt)("td",o({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"CatalogIndexPage"),", ",(0,a.kt)("inlineCode",{parentName:"td"},"SettingsPage"),", ",(0,a.kt)("inlineCode",{parentName:"td"},"LighthousePage"))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",o({parentName:"tr"},{align:null}),"Entity Tab Content"),(0,a.kt)("td",o({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"Entity\\*Content")),(0,a.kt)("td",o({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"EntityJenkinsContent"),", ",(0,a.kt)("inlineCode",{parentName:"td"},"EntityKubernetesContent"))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",o({parentName:"tr"},{align:null}),"Entity Overview Card"),(0,a.kt)("td",o({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"Entity\\*Card")),(0,a.kt)("td",o({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"EntitySentryCard"),", ",(0,a.kt)("inlineCode",{parentName:"td"},"EntityPagerDutyCard"))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",o({parentName:"tr"},{align:null}),"Entity Conditional"),(0,a.kt)("td",o({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"is\\*Available")),(0,a.kt)("td",o({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"isPagerDutyAvailable"),", ",(0,a.kt)("inlineCode",{parentName:"td"},"isJenkinsAvailable"))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",o({parentName:"tr"},{align:null}),"Plugin Instance"),(0,a.kt)("td",o({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"\\*Plugin")),(0,a.kt)("td",o({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"jenkinsPlugin"),", ",(0,a.kt)("inlineCode",{parentName:"td"},"catalogPlugin"))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",o({parentName:"tr"},{align:null}),"Utility API Reference"),(0,a.kt)("td",o({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"\\*ApiRef")),(0,a.kt)("td",o({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"configApiRef"),", ",(0,a.kt)("inlineCode",{parentName:"td"},"catalogApiRef"))))),(0,a.kt)("h3",o({},{id:"routing-system"}),"Routing System"),(0,a.kt)("p",null,"The routing system of Backstage relies heavily on the composability system. It\nuses ",(0,a.kt)("inlineCode",{parentName:"p"},"RouteRef"),"s to represent routing targets in the app, which at runtime will\nbe bound to a concrete ",(0,a.kt)("inlineCode",{parentName:"p"},"path"),", but provides a level of indirection to help mix\ntogether different plugins that otherwise wouldn't know how to route to each\nother."),(0,a.kt)("p",null,"The concrete ",(0,a.kt)("inlineCode",{parentName:"p"},"path")," for each ",(0,a.kt)("inlineCode",{parentName:"p"},"RouteRef")," is discovered based on the element tree\nin the app. Let's consider the following example:"),(0,a.kt)("pre",null,(0,a.kt)("code",o({parentName:"pre"},{className:"language-tsx"}),'const appRoutes = (\n  <Routes>\n    <Route path="/foo" element={<FooPage />} />\n    <Route path="/bar" element={<BarPage />} />\n  </Routes>\n);\n')),(0,a.kt)("p",null,"We'll assume that ",(0,a.kt)("inlineCode",{parentName:"p"},"FooPage")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"BarPage")," are routable extensions, exported by\nthe ",(0,a.kt)("inlineCode",{parentName:"p"},"fooPlugin")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"barPlugin")," respectively. Since the ",(0,a.kt)("inlineCode",{parentName:"p"},"FooPage")," is a routable\nextension it has a ",(0,a.kt)("inlineCode",{parentName:"p"},"RouteRef")," assigned as its mount point, which we'll refer to\nas ",(0,a.kt)("inlineCode",{parentName:"p"},"fooPageRouteRef"),"."),(0,a.kt)("p",null,"Given the above example, the ",(0,a.kt)("inlineCode",{parentName:"p"},"fooPageRouteRef")," will be associated with the\n",(0,a.kt)("inlineCode",{parentName:"p"},"'/foo'")," route. If we want to route to the ",(0,a.kt)("inlineCode",{parentName:"p"},"FooPage"),", we can use the\n",(0,a.kt)("inlineCode",{parentName:"p"},"useRouteRef")," hook to create a concrete link to the page. The ",(0,a.kt)("inlineCode",{parentName:"p"},"useRouteRef")," hook\ntakes a single ",(0,a.kt)("inlineCode",{parentName:"p"},"RouteRef")," as its only parameter, and returns a function that is\ncalled to create the URL. For example like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",o({parentName:"pre"},{className:"language-tsx"}),"const MyComponent = () => {\n  const fooRoute = useRouteRef(fooPageRouteRef);\n  return <a href={fooRoute()}>Link to Foo</a>;\n};\n")),(0,a.kt)("p",null,"Now let's assume that we want to link from the ",(0,a.kt)("inlineCode",{parentName:"p"},"BarPage")," to the ",(0,a.kt)("inlineCode",{parentName:"p"},"FooPage"),". We\ndon't want to reference the ",(0,a.kt)("inlineCode",{parentName:"p"},"fooPageRouteRef")," directly from our ",(0,a.kt)("inlineCode",{parentName:"p"},"barPlugin"),",\nsince that would create an unnecessary dependency on the ",(0,a.kt)("inlineCode",{parentName:"p"},"fooPlugin"),". It would\nalso provided little flexibility in allowing the app to tie plugins together,\nwith the links instead being dictated by the plugins themselves. To solve this,\nwe use ",(0,a.kt)("inlineCode",{parentName:"p"},"ExternalRouteRef"),"s. Much like regular route references, they can be\npassed to ",(0,a.kt)("inlineCode",{parentName:"p"},"useRouteRef")," to create concrete URLs, but they can not be used as\nmount points in routable component and instead have to be associated with a\ntarget route using route bindings in the app."),(0,a.kt)("p",null,"We create a new ",(0,a.kt)("inlineCode",{parentName:"p"},"ExternalRouteRef")," inside the ",(0,a.kt)("inlineCode",{parentName:"p"},"barPlugin"),", using a neutral name\nthat describes its role in the plugin rather than a specific plugin page that it\nmight be linking to, allowing the app to decide the final target. If the\n",(0,a.kt)("inlineCode",{parentName:"p"},"BarPage")," for example wants to link to an external page in the header, it might\ndeclare an ",(0,a.kt)("inlineCode",{parentName:"p"},"ExternalRouteRef")," similar to this:"),(0,a.kt)("pre",null,(0,a.kt)("code",o({parentName:"pre"},{className:"language-ts"}),"const headerLinkRouteRef = createExternalRouteRef({ id: 'header-link' });\n")),(0,a.kt)("h3",o({},{id:"binding-external-routes-in-the-app"}),"Binding External Routes in the App"),(0,a.kt)("p",null,"The association of external routes is controlled by the app. Each\n",(0,a.kt)("inlineCode",{parentName:"p"},"ExternalRouteRef")," of a plugin should be bound to an actual ",(0,a.kt)("inlineCode",{parentName:"p"},"RouteRef"),", usually\nfrom another plugin. The binding process happens once at app startup, and is\nthen used through the lifetime of the app to help resolve concrete route paths."),(0,a.kt)("p",null,"Using the above example of the ",(0,a.kt)("inlineCode",{parentName:"p"},"BarPage")," linking to the ",(0,a.kt)("inlineCode",{parentName:"p"},"FooPage"),", we might do\nsomething like this in the app:"),(0,a.kt)("pre",null,(0,a.kt)("code",o({parentName:"pre"},{className:"language-ts"}),"createApp({\n  bindRoutes({ bind }) {\n    bind(barPlugin.externalRoutes, {\n      headerLink: fooPlugin.routes.root,\n    });\n  },\n});\n")),(0,a.kt)("p",null,"Given the above binding, using ",(0,a.kt)("inlineCode",{parentName:"p"},"useRouteRef(headerLinkRouteRef)")," within the\n",(0,a.kt)("inlineCode",{parentName:"p"},"barPlugin")," will let us create a link to whatever path the ",(0,a.kt)("inlineCode",{parentName:"p"},"FooPage")," is mounted\nat."),(0,a.kt)("p",null,"Note that we are not importing and using the ",(0,a.kt)("inlineCode",{parentName:"p"},"RouteRef"),"s directly in the app,\nand instead rely on the plugin instance to access routes of the plugins. This is\na new convention that was introduced to provide better namespacing and\ndiscoverability of routes, as well as reduce the number of separate exports from\neach plugin package. The route references would be supplied to ",(0,a.kt)("inlineCode",{parentName:"p"},"createPlugin"),"\nlike this:"),(0,a.kt)("pre",null,(0,a.kt)("code",o({parentName:"pre"},{className:"language-ts"}),"// In foo-plugin\nexport const fooPlugin = createPlugin({\n  routes: {\n    root: fooPageRouteRef,\n  },\n  ...\n})\n\n// In bar-plugin\nexport const barPlugin = createPlugin({\n  externalRoutes: {\n    headerLink: headerLinkRouteRef,\n  },\n  ...\n})\n")),(0,a.kt)("p",null,"Also note that you almost always want to create the route references themselves\nin a different file than the one that creates the plugin instance, for example a\ntop-level ",(0,a.kt)("inlineCode",{parentName:"p"},"routes.ts"),". This is to avoid circular imports when you use the route\nreferences from other parts of the same plugin."),(0,a.kt)("p",null,"Another thing to note is that this indirection in the routing is particularly\nuseful for open source plugins that need to leave flexibility in how they are\nintegrated. For plugins that you build internally for your own Backstage\napplication, you can choose to go the route of direct imports or even use\nconcrete routes directly. Although there can be some benefits to using the full\nrouting system even in internal plugins. It can help you structure your routes,\nand as you will see further down it also helps you manage route parameters."),(0,a.kt)("h3",o({},{id:"optional-external-routes"}),"Optional External Routes"),(0,a.kt)("p",null,"When creating an ",(0,a.kt)("inlineCode",{parentName:"p"},"ExternalRouteRef")," it is possible to mark it as optional:"),(0,a.kt)("pre",null,(0,a.kt)("code",o({parentName:"pre"},{className:"language-ts"}),"const headerLinkRouteRef = createExternalRouteRef({\n  id: 'header-link',\n  optional: true,\n});\n")),(0,a.kt)("p",null,"An external route that is marked as optional is not required to be bound in the\napp, allowing it to be used as a switch for whether a particular link should be\ndisplayed or action should be taken."),(0,a.kt)("p",null,"When calling ",(0,a.kt)("inlineCode",{parentName:"p"},"useRouteRef")," with an optional external route, its return signature\nis changed to ",(0,a.kt)("inlineCode",{parentName:"p"},"RouteFunc | undefined"),", allowing for logic like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",o({parentName:"pre"},{className:"language-tsx"}),"const MyComponent = () => {\n  const headerLink = useRouteRef(headerLinkRouteRef);\n\n  return (\n    <header>\n      My Header\n      {headerLink && <a href={headerLink()}>External Link</a>}\n    </header>\n  );\n};\n")),(0,a.kt)("h3",o({},{id:"parameterized-routes"}),"Parameterized Routes"),(0,a.kt)("p",null,"A feature of ",(0,a.kt)("inlineCode",{parentName:"p"},"RouteRef"),"s is the possibility of adding named and typed\nparameters. Parameters are declared at creation, and will enforce presence of\nthe parameters in the path in the app, and require them as a parameter when\nusing ",(0,a.kt)("inlineCode",{parentName:"p"},"useRouteRef"),"."),(0,a.kt)("p",null,"The following is an example of creation and usage of a parameterized route:"),(0,a.kt)("pre",null,(0,a.kt)("code",o({parentName:"pre"},{className:"language-tsx"}),"// Creation of a parameterized route\nconst myRouteRef = createRouteRef({\n  id: 'myroute',\n  params: ['name']\n})\n\n// In the app, where MyPage is a routable extension with myRouteRef set as mountPoint\n<Route path='/my-page/:name' element={<MyPage />}/>\n\n// Usage within a component\nconst myRoute = useRouteRef(myRouteRef)\nreturn (\n  <div>\n    <a href={myRoute({name: 'a'})}>A</a>\n    <a href={myRoute({name: 'b'})}>B</a>\n  </div>\n)\n")),(0,a.kt)("p",null,"It is currently not possible to have parameterized ",(0,a.kt)("inlineCode",{parentName:"p"},"ExternalRouteRef"),"s, or to\nbind an external route to a parameterized route, although this may be added in\nthe future if needed."),(0,a.kt)("h3",o({},{id:"subroutes"}),"Subroutes"),(0,a.kt)("p",null,"The last kind of route refs that can be created are ",(0,a.kt)("inlineCode",{parentName:"p"},"SubRouteRef"),"s, which can be\nused to create a route ref with a fixed path relative to an absolute ",(0,a.kt)("inlineCode",{parentName:"p"},"RouteRef"),".\nThey are useful if you have a page that internally is mounted at a sub route of\na routable extension component, and you want other plugins to be able to route\nto that page."),(0,a.kt)("p",null,"For example:"),(0,a.kt)("pre",null,(0,a.kt)("code",o({parentName:"pre"},{className:"language-tsx"}),"// routes.ts\nconst rootRouteRef = createRouteRef({ id: 'root' });\nconst detailsRouteRef = createSubRouteRef({\n  id: 'root-sub',\n  parent: rootRouteRef,\n  path: '/details',\n});\n\n// plugin.ts\nexport const myPlugin = createPlugin({\n  routes: {\n    root: rootRouteRef,\n    details: detailsRouteRef,\n  },\n});\n\nexport const MyPage = myPlugin.provide(\n  createRoutableExtension({\n    name: 'MyPage',\n    component: () => import('./components/MyPage').then(m => m.MyPage),\n    mountPoint: rootRouteRef,\n  }),\n);\n\n// components/MyPage.tsx\nconst MyPage = () => (\n  <Routes>\n    {/* myPlugin.routes.root will take the user to this page */}\n    <Route path=\"/\" element={<IndexPage />} />\n\n    {/* myPlugin.routes.details will take the user to this page */}\n    <Route path=\"/details\" element={<DetailsPage />} />\n  </Routes>\n);\n")),(0,a.kt)("h3",o({},{id:"catalog-components"}),"Catalog Components"),(0,a.kt)("p",null,"To help structure the catalog entity pages in your app and choose what content\nto render in different scenarios, the ",(0,a.kt)("inlineCode",{parentName:"p"},"@backstage/catalog")," plugin provides an\n",(0,a.kt)("inlineCode",{parentName:"p"},"EntitySwitch")," component. It works by selecting at most one element to render\nusing a list of ",(0,a.kt)("inlineCode",{parentName:"p"},"EntitySwitch.Case")," children."),(0,a.kt)("p",null,"For example, if you want all entities of kind ",(0,a.kt)("inlineCode",{parentName:"p"},'"Template"')," to be rendered with a\n",(0,a.kt)("inlineCode",{parentName:"p"},"MyTemplate")," component, and all other entities to be rendered with a ",(0,a.kt)("inlineCode",{parentName:"p"},"MyOther"),"\ncomponent, you would do the following:"),(0,a.kt)("pre",null,(0,a.kt)("code",o({parentName:"pre"},{className:"language-tsx"}),"<EntitySwitch>\n  <EntitySwitch.Case if={isKind('template')}>\n    <MyTemplate />\n  </EntitySwitch.Case>\n\n  <EntitySwitch.Case>\n    <MyOther />\n  </EntitySwitch.Case>\n</EntitySwitch>\n\n// Shorter form if desired:\n<EntitySwitch>\n  <EntitySwitch.Case if={isKind('template')} children={<MyTemplate />}/>\n  <EntitySwitch.Case children={<MyOther />}/>\n</EntitySwitch>\n")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"EntitySwitch")," component will render the children of the first\n",(0,a.kt)("inlineCode",{parentName:"p"},"EntitySwitch.Case")," that returns ",(0,a.kt)("inlineCode",{parentName:"p"},"true")," when the selected entity is passed to\nthe function of the ",(0,a.kt)("inlineCode",{parentName:"p"},"if")," prop. If none of the cases match, no children will be\nrendered, and if a case doesn't specify an ",(0,a.kt)("inlineCode",{parentName:"p"},"if")," filter function, it will always\nmatch. The ",(0,a.kt)("inlineCode",{parentName:"p"},"if")," property is simply a function of the type\n",(0,a.kt)("inlineCode",{parentName:"p"},"(entity: Entity) => boolean"),", for example, ",(0,a.kt)("inlineCode",{parentName:"p"},"isKind")," can be implemented like\nthis:"),(0,a.kt)("pre",null,(0,a.kt)("code",o({parentName:"pre"},{className:"language-ts"}),"function isKind(kind: string) {\n  return (entity: Entity) => entity.kind.toLowerCase() === kind.toLowerCase();\n}\n")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"@backstage/catalog")," plugin provides a couple of built-in conditions,\n",(0,a.kt)("inlineCode",{parentName:"p"},"isKind"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"isComponentType"),", and ",(0,a.kt)("inlineCode",{parentName:"p"},"isNamespace"),"."),(0,a.kt)("p",null,"In addition to the ",(0,a.kt)("inlineCode",{parentName:"p"},"EntitySwitch")," component, the catalog plugin also exports a\nnew ",(0,a.kt)("inlineCode",{parentName:"p"},"EntityLayout")," component. It is a tweaked version and replacement for the\n",(0,a.kt)("inlineCode",{parentName:"p"},"EntityPageLayout")," component, and is introduced more in depth in the app\nmigration section below."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"NOTE"),": The rest of this documentation covers how to migrate older\napplications to the new composability system described above."),(0,a.kt)("h2",o({},{id:"porting-existing-plugins"}),"Porting Existing Plugins"),(0,a.kt)("p",null,"There are a couple of high-level steps to porting an existing plugin to the new\ncomposability system:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Remove usage of ",(0,a.kt)("inlineCode",{parentName:"li"},"router.addRoute")," or ",(0,a.kt)("inlineCode",{parentName:"li"},"router.registerRoute")," within\n",(0,a.kt)("inlineCode",{parentName:"li"},"createPlugin"),", and export the page components as routable extensions instead."),(0,a.kt)("li",{parentName:"ul"},"Switch any ",(0,a.kt)("inlineCode",{parentName:"li"},"Router")," export to instead be a routable extension."),(0,a.kt)("li",{parentName:"ul"},"Change any plain component exports, such as catalog overview cards, to be\ncomponent extensions."),(0,a.kt)("li",{parentName:"ul"},"Stop exporting ",(0,a.kt)("inlineCode",{parentName:"li"},"RouteRef"),"s and instead pass them to ",(0,a.kt)("inlineCode",{parentName:"li"},"createPlugin"),"."),(0,a.kt)("li",{parentName:"ul"},"Stop accepting ",(0,a.kt)("inlineCode",{parentName:"li"},"RouteRef"),"s as props or importing them from other plugins,\ninstead create an ",(0,a.kt)("inlineCode",{parentName:"li"},"ExternalRouteRef")," as a replacement, and pass it to\n",(0,a.kt)("inlineCode",{parentName:"li"},"createPlugin.")),(0,a.kt)("li",{parentName:"ul"},"Rename any other exported symbols according to the naming pattern table below.")),(0,a.kt)("p",null,"Note that removing the existing exports and configuration is a breaking change\nin any plugin. If backwards compatibility is needed the existing code be\ndeprecated while making the new additions, to then be removed at a later point."),(0,a.kt)("h3",o({},{id:"naming-patterns-1"}),"Naming Patterns"),(0,a.kt)("p",null,"Many export naming patterns have been changed to avoid import aliases and to\nclarify intent. Refer to the following table to formulate the new name:"),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",o({parentName:"tr"},{align:null}),"Description"),(0,a.kt)("th",o({parentName:"tr"},{align:null}),"Existing Pattern"),(0,a.kt)("th",o({parentName:"tr"},{align:null}),"New Pattern"),(0,a.kt)("th",o({parentName:"tr"},{align:null}),"Examples"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",o({parentName:"tr"},{align:null}),"Top-level Pages"),(0,a.kt)("td",o({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"Router")),(0,a.kt)("td",o({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"\\*Page")),(0,a.kt)("td",o({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"CatalogIndexPage"),", ",(0,a.kt)("inlineCode",{parentName:"td"},"SettingsPage"),", ",(0,a.kt)("inlineCode",{parentName:"td"},"LighthousePage"))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",o({parentName:"tr"},{align:null}),"Entity Tab Content"),(0,a.kt)("td",o({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"Router")),(0,a.kt)("td",o({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"Entity\\*Content")),(0,a.kt)("td",o({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"EntityJenkinsContent"),", ",(0,a.kt)("inlineCode",{parentName:"td"},"EntityKubernetesContent"))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",o({parentName:"tr"},{align:null}),"Entity Overview Card"),(0,a.kt)("td",o({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"\\*Card")),(0,a.kt)("td",o({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"Entity\\*Card")),(0,a.kt)("td",o({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"EntitySentryCard"),", ",(0,a.kt)("inlineCode",{parentName:"td"},"EntityPagerDutyCard"))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",o({parentName:"tr"},{align:null}),"Entity Conditional"),(0,a.kt)("td",o({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"isPluginApplicableToEntity")),(0,a.kt)("td",o({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"is\\*Available")),(0,a.kt)("td",o({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"isPagerDutyAvailable"),", ",(0,a.kt)("inlineCode",{parentName:"td"},"isJenkinsAvailable"))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",o({parentName:"tr"},{align:null}),"Plugin Instance"),(0,a.kt)("td",o({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"plugin")),(0,a.kt)("td",o({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"\\*Plugin")),(0,a.kt)("td",o({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"jenkinsPlugin"),", ",(0,a.kt)("inlineCode",{parentName:"td"},"catalogPlugin"))))))}c.isMDXComponent=!0},862525:e=>{var t=Object.getOwnPropertySymbols,n=Object.prototype.hasOwnProperty,a=Object.prototype.propertyIsEnumerable;function o(e){if(null==e)throw new TypeError("Object.assign cannot be called with null or undefined");return Object(e)}e.exports=function(){try{if(!Object.assign)return!1;var e=new String("abc");if(e[5]="de","5"===Object.getOwnPropertyNames(e)[0])return!1;for(var t={},n=0;n<10;n++)t["_"+String.fromCharCode(n)]=n;if("0123456789"!==Object.getOwnPropertyNames(t).map((function(e){return t[e]})).join(""))return!1;var a={};return"abcdefghijklmnopqrst".split("").forEach((function(e){a[e]=e})),"abcdefghijklmnopqrst"===Object.keys(Object.assign({},a)).join("")}catch(o){return!1}}()?Object.assign:function(e,i){for(var r,l,p=o(e),s=1;s<arguments.length;s++){for(var u in r=Object(arguments[s]))n.call(r,u)&&(p[u]=r[u]);if(t){l=t(r);for(var d=0;d<l.length;d++)a.call(r,l[d])&&(p[l[d]]=r[l[d]])}}return p}},541535:(e,t,n)=>{var a=n(862525),o=60103,i=60106;var r=60109,l=60110,p=60112;var s=60115,u=60116;if("function"==typeof Symbol&&Symbol.for){var d=Symbol.for;o=d("react.element"),i=d("react.portal"),d("react.fragment"),d("react.strict_mode"),d("react.profiler"),r=d("react.provider"),l=d("react.context"),p=d("react.forward_ref"),d("react.suspense"),s=d("react.memo"),u=d("react.lazy")}var c="function"==typeof Symbol&&Symbol.iterator;function m(e){for(var t="https://reactjs.org/docs/error-decoder.html?invariant="+e,n=1;n<arguments.length;n++)t+="&args[]="+encodeURIComponent(arguments[n]);return"Minified React error #"+e+"; visit "+t+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var h={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},g={};function f(e,t,n){this.props=e,this.context=t,this.refs=g,this.updater=n||h}function k(){}function y(e,t,n){this.props=e,this.context=t,this.refs=g,this.updater=n||h}f.prototype.isReactComponent={},f.prototype.setState=function(e,t){if("object"!=typeof e&&"function"!=typeof e&&null!=e)throw Error(m(85));this.updater.enqueueSetState(this,e,t,"setState")},f.prototype.forceUpdate=function(e){this.updater.enqueueForceUpdate(this,e,"forceUpdate")},k.prototype=f.prototype;var b=y.prototype=new k;b.constructor=y,a(b,f.prototype),b.isPureReactComponent=!0;var N={current:null},C=Object.prototype.hasOwnProperty,w={key:!0,ref:!0,__self:!0,__source:!0};function v(e,t,n){var a,i={},r=null,l=null;if(null!=t)for(a in void 0!==t.ref&&(l=t.ref),void 0!==t.key&&(r=""+t.key),t)C.call(t,a)&&!w.hasOwnProperty(a)&&(i[a]=t[a]);var p=arguments.length-2;if(1===p)i.children=n;else if(1<p){for(var s=Array(p),u=0;u<p;u++)s[u]=arguments[u+2];i.children=s}if(e&&e.defaultProps)for(a in p=e.defaultProps)void 0===i[a]&&(i[a]=p[a]);return{$$typeof:o,type:e,key:r,ref:l,props:i,_owner:N.current}}function R(e){return"object"==typeof e&&null!==e&&e.$$typeof===o}var x=/\/+/g;function P(e,t){return"object"==typeof e&&null!==e&&null!=e.key?function(e){var t={"=":"=0",":":"=2"};return"$"+e.replace(/[=:]/g,(function(e){return t[e]}))}(""+e.key):t.toString(36)}function E(e,t,n,a,r){var l=typeof e;"undefined"!==l&&"boolean"!==l||(e=null);var p=!1;if(null===e)p=!0;else switch(l){case"string":case"number":p=!0;break;case"object":switch(e.$$typeof){case o:case i:p=!0}}if(p)return r=r(p=e),e=""===a?"."+P(p,0):a,Array.isArray(r)?(n="",null!=e&&(n=e.replace(x,"$&/")+"/"),E(r,t,n,"",(function(e){return e}))):null!=r&&(R(r)&&(r=function(e,t){return{$$typeof:o,type:e.type,key:t,ref:e.ref,props:e.props,_owner:e._owner}}(r,n+(!r.key||p&&p.key===r.key?"":(""+r.key).replace(x,"$&/")+"/")+e)),t.push(r)),1;if(p=0,a=""===a?".":a+":",Array.isArray(e))for(var s=0;s<e.length;s++){var u=a+P(l=e[s],s);p+=E(l,t,n,u,r)}else if(u=function(e){return null===e||"object"!=typeof e?null:"function"==typeof(e=c&&e[c]||e["@@iterator"])?e:null}(e),"function"==typeof u)for(e=u.call(e),s=0;!(l=e.next()).done;)p+=E(l=l.value,t,n,u=a+P(l,s++),r);else if("object"===l)throw t=""+e,Error(m(31,"[object Object]"===t?"object with keys {"+Object.keys(e).join(", ")+"}":t));return p}function O(e,t,n){if(null==e)return e;var a=[],o=0;return E(e,a,"","",(function(e){return t.call(n,e,o++)})),a}function T(e){if(-1===e._status){var t=e._result;t=t(),e._status=0,e._result=t,t.then((function(t){0===e._status&&(t=t.default,e._status=1,e._result=t)}),(function(t){0===e._status&&(e._status=2,e._result=t)}))}if(1===e._status)return e._result;throw e._result}var S={current:null};function j(){var e=S.current;if(null===e)throw Error(m(321));return e}},827378:(e,t,n)=>{n(541535)}}]);