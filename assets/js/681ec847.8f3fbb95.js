/*! For license information please see 681ec847.8f3fbb95.js.LICENSE.txt */
"use strict";(self.webpackChunkbackstage_microsite=self.webpackChunkbackstage_microsite||[]).push([[345809],{603905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var a=n(667294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},u="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=c(n),d=o,m=u["".concat(l,".").concat(d)]||u[d]||h[d]||r;return n?a.createElement(m,i(i({ref:t},p),{},{components:n})):a.createElement(m,i({ref:t},p))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[u]="string"==typeof e?e:o,i[1]=s;for(var c=2;c<r;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},494283:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>i,metadata:()=>l,toc:()=>p});n(827378);var a=n(603905);function o(){return o=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},o.apply(this,arguments)}function r(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}const i={id:"external-integrations",title:"External integrations",description:"Documentation on External integrations to integrate systems with Backstage"},s=void 0,l={unversionedId:"features/software-catalog/external-integrations",id:"features/software-catalog/external-integrations",title:"External integrations",description:"Documentation on External integrations to integrate systems with Backstage",source:"@site/../docs/features/software-catalog/external-integrations.md",sourceDirName:"features/software-catalog",slug:"/features/software-catalog/external-integrations",permalink:"/docs/features/software-catalog/external-integrations",draft:!1,editUrl:"https://github.com/backstage/backstage/edit/master/docs/../docs/features/software-catalog/external-integrations.md",tags:[],version:"current",frontMatter:{id:"external-integrations",title:"External integrations",description:"Documentation on External integrations to integrate systems with Backstage"},sidebar:"docs",previous:{title:"Extending the model",permalink:"/docs/features/software-catalog/extending-the-model"},next:{title:"Catalog Customization",permalink:"/docs/features/software-catalog/catalog-customization"}},c={},p=[{value:"Background",id:"background",level:2},{value:"Custom Entity Providers",id:"custom-entity-providers",level:2},{value:"Creating an Entity Provider",id:"creating-an-entity-provider",level:3},{value:"Provider Mutations",id:"provider-mutations",level:3},{value:"Installing the Provider",id:"installing-the-provider",level:3},{value:"Example User Entity Provider",id:"example-user-entity-provider",level:3},{value:"Custom Processors",id:"custom-processors",level:2},{value:"Processors and the Ingestion Loop",id:"processors-and-the-ingestion-loop",level:3},{value:"Deciding on the New Locations",id:"deciding-on-the-new-locations",level:3},{value:"Creating a Catalog Data Reader Processor",id:"creating-a-catalog-data-reader-processor",level:3},{value:"Caching processing results",id:"caching-processing-results",level:3}],u={toc:p};function h(e){var{components:t}=e,n=r(e,["components"]);return(0,a.kt)("wrapper",o({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Backstage natively supports importing catalog data through the use of\n",(0,a.kt)("a",o({parentName:"p"},{href:"/docs/features/software-catalog/descriptor-format"}),"entity descriptor YAML files"),". However, companies that\nalready have an existing system for keeping track of software and its owners can\nleverage those systems by integrating them with Backstage. This article shows\nthe two common ways of doing that integration: by adding a custom catalog\n",(0,a.kt)("em",{parentName:"p"},"entity provider"),", or by adding a ",(0,a.kt)("em",{parentName:"p"},"processor"),"."),(0,a.kt)("h2",o({},{id:"background"}),"Background"),(0,a.kt)("p",null,"The catalog has a frontend plugin part, that communicates via a service API to\nthe backend plugin part. The backend continuously ingests data from the sources\nyou specify, to store them in its database. The details of how this works is\ndetailed in ",(0,a.kt)("a",o({parentName:"p"},{href:"/docs/features/software-catalog/life-of-an-entity"}),"The Life of an Entity"),". Reading that article\nfirst is recommended."),(0,a.kt)("p",null,"There are two main options for how to ingest data into the catalog: making a\n",(0,a.kt)("a",o({parentName:"p"},{href:"#custom-entity-providers"}),"custom entity provider"),", or making a\n",(0,a.kt)("a",o({parentName:"p"},{href:"#custom-processors"}),"custom processor"),". They both have strengths and drawbacks,\nbut the former would usually be preferred. Both options are presented in a\ndedicated subsection below."),(0,a.kt)("h2",o({},{id:"custom-entity-providers"}),"Custom Entity Providers"),(0,a.kt)("p",null,"Entity providers sit at the very edge of the catalog. They are the original\nsources of entities that form roots of the processing tree. The dynamic location\nstore API, and the static locations you can specify in your app-config, are two\nexamples of builtin providers in the catalog."),(0,a.kt)("p",null,"Some defining traits of entity providers:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"You instantiate them individually using code in your backend, and pass them to\nthe catalog builder. Often there's one provider instance per remote system."),(0,a.kt)("li",{parentName:"ul"},"You may be responsible for actively running them. For example, some providers\nneed to be triggered periodically by a method call to know when they are meant\nto do their job; in that case you'll have to make that happen."),(0,a.kt)("li",{parentName:"ul"},"The timing of their work is entirely detached from the processing loops. One\nprovider may run every 30 seconds, another one on every incoming webhook call\nof a certain type, etc."),(0,a.kt)("li",{parentName:"ul"},"They can perform detailed updates on the set of entities that they are\nresponsible for. They can make full updates of the entire set, or issue\nindividual additions and removals."),(0,a.kt)("li",{parentName:"ul"},"Their output is a set of unprocessed entities. Those are then subject to the\nprocessing loops before becoming final, stitched entities."),(0,a.kt)("li",{parentName:"ul"},"When they remove an entity, the entire subtree of processor-generated entities\nunder that root is eagerly removed as well.")),(0,a.kt)("h3",o({},{id:"creating-an-entity-provider"}),"Creating an Entity Provider"),(0,a.kt)("p",null,"The recommended way of instantiating the catalog backend classes is to use the\n",(0,a.kt)("inlineCode",{parentName:"p"},"CatalogBuilder"),", as illustrated in the\n",(0,a.kt)("a",o({parentName:"p"},{href:"https://github.com/backstage/backstage/blob/master/packages/backend/src/plugins/catalog.ts"}),"example backend here"),".\nWe will create a new\n",(0,a.kt)("a",o({parentName:"p"},{href:"https://github.com/backstage/backstage/blob/master/plugins/catalog-node/src/api/provider.ts"}),(0,a.kt)("inlineCode",{parentName:"a"},"EntityProvider")),"\nsubclass that can be added to this catalog builder."),(0,a.kt)("p",null,"Let's make a simple provider that can refresh a set of entities based on a\nremote store. The provider part of the interface is actually tiny - you only\nhave to supply a (unique) name, and accept a connection from the environment\nthrough which you can issue writes. The rest is up to the individual provider\nimplementation."),(0,a.kt)("p",null,"It is up to you where you put the code for this new processor class. For quick\nexperimentation you could place it in your backend package, but we recommend\nputting all extensions like this in a backend plugin package of their own in the\n",(0,a.kt)("inlineCode",{parentName:"p"},"plugins")," folder of your Backstage repo."),(0,a.kt)("p",null,"The class will have this basic structure:"),(0,a.kt)("pre",null,(0,a.kt)("code",o({parentName:"pre"},{className:"language-ts"}),"import { UrlReader } from '@backstage/backend-common';\nimport { Entity } from '@backstage/catalog-model';\nimport {\n  EntityProvider,\n  EntityProviderConnection,\n} from '@backstage/plugin-catalog-node';\n\n/**\n * Provides entities from fictional frobs service.\n */\nexport class FrobsProvider implements EntityProvider {\n  private readonly env: string;\n  private readonly reader: UrlReader;\n  private connection?: EntityProviderConnection;\n\n  /** [1] */\n  constructor(env: string, reader: UrlReader) {\n    this.env = env;\n    this.reader = reader;\n  }\n\n  /** [2] */\n  getProviderName(): string {\n    return `frobs-${this.env}`;\n  }\n\n  /** [3] */\n  async connect(connection: EntityProviderConnection): Promise<void> {\n    this.connection = connection;\n  }\n\n  /** [4] */\n  async run(): Promise<void> {\n    if (!this.connection) {\n      throw new Error('Not initialized');\n    }\n\n    const response = await this.reader.readUrl(\n      `https://frobs-${this.env}.example.com/data`,\n    );\n    const data = JSON.parse(await response.buffer()).toString();\n\n    /** [5] */\n    const entities: Entity[] = frobsToEntities(data);\n\n    /** [6] */\n    await this.connection.applyMutation({\n      type: 'full',\n      entities: entities.map(entity => ({\n        entity,\n        locationKey: `frobs-provider:${this.env}`,\n      })),\n    });\n  }\n}\n")),(0,a.kt)("p",null,"This class demonstrates several important concepts, some of which are optional.\nCheck out the numbered markings - let's go through them one by one."),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"The class takes an ",(0,a.kt)("inlineCode",{parentName:"li"},"env")," parameter. This is only illustrative for the sake of\nthe example. We'll use this field to exhibit the type of provider where end\nusers may want or need to make multiple instances of the same provider, and\nwhat the implications would be in that case."),(0,a.kt)("li",{parentName:"ol"},"The catalog requires that all registered providers return a name that is\n",(0,a.kt)("em",{parentName:"li"},"unique")," among those providers, and which is ",(0,a.kt)("em",{parentName:"li"},"stable")," over time. The reason\nfor these requirements is, the emitted entities for each provider instance\nall hang around in a closed bucket of their own. This bucket needs to be tied\nto their provider over time, and across backend restarts. We'll see below how\nthe processor emits some entities and what that means for its own bucket."),(0,a.kt)("li",{parentName:"ol"},"Once the catalog engine starts up, it immediately issues the ",(0,a.kt)("inlineCode",{parentName:"li"},"connect")," call\nto all known providers. This forms the bond between the code and the\ndatabase. This is also an opportunity for the provider to do one-time updates\non the connection at startup if it wants to."),(0,a.kt)("li",{parentName:"ol"},"At this point the provider contract is already complete. But the class needs\nto do some actual work too! In this particular example, we chose to make a\n",(0,a.kt)("inlineCode",{parentName:"li"},"run")," method that has to be called each time that you want to issue a sync\nwith the ",(0,a.kt)("inlineCode",{parentName:"li"},"frobs")," service. Let's repeat that - this is only an example\nimplementation; some providers may be written in entirely different ways,\nsuch as for example subscribing to pubsub events and only reacting to those,\nor any number of other solutions. The only point is - external stimuli happen\nsomehow, which somehow get translated to calls on the ",(0,a.kt)("inlineCode",{parentName:"li"},"connection")," to persist\nthe outcome of that. This example issues a ",(0,a.kt)("inlineCode",{parentName:"li"},"fetch")," to the right service and\nissues a full refresh of its entity bucket based on that."),(0,a.kt)("li",{parentName:"ol"},"The method translates the foreign data model to the native ",(0,a.kt)("inlineCode",{parentName:"li"},"Entity")," form, as\nexpected by the catalog. The ",(0,a.kt)("inlineCode",{parentName:"li"},"Entity")," must include the\n",(0,a.kt)("inlineCode",{parentName:"li"},"backstage.io/managed-by-location")," and\n",(0,a.kt)("inlineCode",{parentName:"li"},"backstage.io/managed-by-origin-location annotations"),"; otherwise, it will not\nappear in the Catalog and will generate warning logs. The\n",(0,a.kt)("a",o({parentName:"li"},{href:"/docs/features/software-catalog/well-known-annotations#backstageiomanaged-by-location"}),"Well-known Annotations"),"\ndocumentation has guidance on what values to use for these."),(0,a.kt)("li",{parentName:"ol"},'Finally, we issue a "mutation" to the catalog. This persists the entities in\nour own bucket, along with an optional ',(0,a.kt)("inlineCode",{parentName:"li"},"locationKey")," that's used for conflict\nchecks. But this is a bigger topic - mutations warrant their own explanatory\nsection below.")),(0,a.kt)("h3",o({},{id:"provider-mutations"}),"Provider Mutations"),(0,a.kt)("p",null,"Let's circle back to the bucket analogy."),(0,a.kt)("p",null,"Each provider ",(0,a.kt)("em",{parentName:"p"},"instance"),' - not each class but each instance registered with the\ncatalog - has access to its own bucket of entities, and the bucket is identified\nby the stable name of the provider instance. Every time the provider issues\n"mutations", it changes the contents of that bucket. Nothing else outside of the\nbucket is accessible.'),(0,a.kt)("p",null,"There are two different types of mutation."),(0,a.kt)("p",null,"The first is ",(0,a.kt)("inlineCode",{parentName:"p"},"'full'"),", which means to figuratively throw away the contents of\nthe bucket and replacing it with all of the new contents specified. Under the\nhood, this is actually implemented through a highly efficient delta mechanism\nfor performance reasons, since it is common that the difference from one run to\nthe other is actually very small. This strategy is convenient for providers that\nhave easy access to batch-fetches of the entire subject material from a remote\nsource, and doesn't have access to, or does not want to compute, deltas."),(0,a.kt)("p",null,"The other mutation type is ",(0,a.kt)("inlineCode",{parentName:"p"},"'delta'"),", which lets the provider explicitly upsert\nor delete entities in its bucket. This mutation is convenient e.g. for event\nbased providers, and can also be more performant since no deltas need to be\ncomputed, and previous bucket contents outside of the targeted set do not have\nto be taken into account."),(0,a.kt)("p",null,"In all cases, the mutation entities are treated as ",(0,a.kt)("em",{parentName:"p"},"unprocessed")," entities. When\nthey land in the database, the registered catalog processors go to work on them\nto transform them into final, processed and stitched, entities ready for\nconsumption."),(0,a.kt)("p",null,"Every entity emitted by a processor can have a ",(0,a.kt)("inlineCode",{parentName:"p"},"locationKey"),", as shown above.\nThis is a critical conflict resolution key, in the form of an opaque string that\nshould be unique for each location that an entity could be located at, and\nundefined if the entity does not have a fixed location."),(0,a.kt)("p",null,"In practice it should be set to the serialized location reference if the entity\nis stored in Git, for example\n",(0,a.kt)("inlineCode",{parentName:"p"},"https://github.com/backstage/backstage/blob/master/catalog-info.yaml"),", or a\nsimilar string that distinctly pins down its origins. In our example we set it\nto a string that was distinct for the provider class, plus its instance\nidentifying properties which in this case was the ",(0,a.kt)("inlineCode",{parentName:"p"},"env"),"."),(0,a.kt)("p",null,'A conflict between two entity definitions happen when they have the same entity\nreference, i.e. kind, namespace, and name. In the event of a conflict, such as\nif two "competing" providers try to emit entities that have the same reference\ntriplet, the location key will be used according to the following rules to\nresolve the conflict:'),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"If the entity is already present in the database but does not have a location\nkey set, the new entity wins and will override the existing one."),(0,a.kt)("li",{parentName:"ul"},"If the entity is already present in the database the new entity will only win\nif the location keys of the existing and new entity are the same."),(0,a.kt)("li",{parentName:"ul"},"If the entity is not already present, insert the entity into the database\nalong with the provided location key.")),(0,a.kt)("p",null,'This may seem complex, but is a vital mechanism for ensuring that users aren\'t\npermitted to do "rogue" takeovers of already registered entities that belong to\nothers.'),(0,a.kt)("h3",o({},{id:"installing-the-provider"}),"Installing the Provider"),(0,a.kt)("p",null,"You should now be able to add this class to your backend in\n",(0,a.kt)("inlineCode",{parentName:"p"},"packages/backend/src/plugins/catalog.ts"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",o({parentName:"pre"},{className:"language-diff"}),"+import { FrobsProvider } from '../path/to/class';\n\n export default async function createPlugin(\n   env: PluginEnvironment,\n ): Promise<Router> {\n   const builder = CatalogBuilder.create(env);\n\n+  const frobs = new FrobsProvider('production', env.reader);\n+  builder.addEntityProvider(frobs);\n\n   const { processingEngine, router } = await builder.build();\n   await processingEngine.start();\n\n+  await env.scheduler.scheduleTask({\n+    id: 'run_frobs_refresh',\n+    fn: async () => { await frobs.run(); },\n+    frequency: { minutes: 30 },\n+    timeout: { minutes: 10 },\n+  });\n")),(0,a.kt)("p",null,"Note that we used the builtin scheduler facility to regularly call the ",(0,a.kt)("inlineCode",{parentName:"p"},"run"),"\nmethod of the provider, in this example. It is a suitable driver for this\nparticular type of recurring task. We placed the scheduling after the actual\nconstruction and startup phase of the rest of the catalog, because at that point\nthe ",(0,a.kt)("inlineCode",{parentName:"p"},"connect")," call has been made to the provider."),(0,a.kt)("p",null,"Start up the backend - it should now start reading from the previously\nregistered location and you'll see your entities start to appear in Backstage."),(0,a.kt)("h3",o({},{id:"example-user-entity-provider"}),"Example User Entity Provider"),(0,a.kt)("p",null,"If you have a 3rd party entity provider such as an internal HR system that you wish to use you are not limited to using our entity providers, (or simply wish to add to existing entity providers with your own data)."),(0,a.kt)("p",null,"We can create an entity provider to read entities that are based off that provider."),(0,a.kt)("p",null,"We create a basic entity provider as shown above. In the example below we might want to extract our users from an HR system, I am assuming the HR system already has the slackUserId to get that information please see the ",(0,a.kt)("a",o({parentName:"p"},{href:"https://api.slack.com/methods"}),"Slack Api"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",o({parentName:"pre"},{className:"language-typescript"}),"import {\n  ANNOTATION_LOCATION,\n  ANNOTATION_ORIGIN_LOCATION,\n} from '@backstage/catalog-model'\nimport {\n  EntityProvider,\n  EntityProviderConnection,\n} from '@backstage/plugin-catalog-backend'\nimport { WebClient } from '@slack/web-api'\nimport {kebabCase} from 'lodash'\n\ninterface Staff {\n  displayName: string\n  slackUserId: string\n  jobTitle: string\n  photoUrl: string\n  address: string\n  email:string\n}\n\nexport class UserEntityProvider implements EntityProvider {\n  private readonly getStaffUrl: string\n  protected readonly slackTeam: string\n  protected readonly slackToken: string\n  protected connection?: EntityProviderConnection\n\n  static fromConfig(config: Config, options: { logger: Logger }) {\n    const getStaffUrl = config.getString('staff.url')\n    const slackToken = config.getString('slack.token')\n    const slackTeam = config.getString('slack.team')\n    return new UserEntityProvider({\n      ...options,\n      getStaffUrl,\n      slackToken,\n      slackTeam,\n    })\n  }\n\n  private constructor(options: {\n    getStaffUrl: string\n    slackToken: string\n    slackTeam: string\n  }) {\n    this.getStaffUrl = options.getStaffUrl\n    this.slackToken = options.slackToken\n    this.slackTeam = options.slackTeam\n  }\n\n  async getAllStaff(): Promise<Staff[]>{\n    await return axios.get(this.getStaffUrl)\n  }\n\n  public async connect(connection: EntityProviderConnection): Promise<void> {\n    this.connection = connection\n  }\n\n  async run(): Promise<void> {\n    if (!this.connection) {\n      throw new Error('User Connection Not initialized')\n    }\n\n    const userResources: UserEntity[] = []\n    const staff = await this.getAllStaff()\n\n    for (const user of staff) {\n      // we can add any links here in this case it would be adding a slack link to the users so you can directly slack them.\n      const links =\n        user.slackUserId != null && user.slackUserId.length > 0\n          ? [\n              {\n                url: `slack://user?team=${this.slackTeam}&id=${user.slackUserId}`,\n                title: 'Slack',\n                icon: 'message',\n              },\n            ]\n          : undefined\n      const userEntity: UserEntity = {\n        kind: 'User',\n        apiVersion: 'backstage.io/v1alpha1',\n        metadata: {\n          annotations: {\n            [ANNOTATION_LOCATION]: 'hr-user-https://www.hrurl.com/',\n            [ANNOTATION_ORIGIN_LOCATION]: 'hr-user-https://www.hrurl.com/',\n          },\n          links,\n          // name of the entity\n          name: kebabCase(user.displayName),\n          // name for display purposes could be anything including email\n          title: user.displayName,\n        },\n        spec: {\n          profile: {\n            displayName: user.displayName,\n            email: user.email,\n            picture: user.photoUrl,\n          },\n          memberOf: [],\n        },\n      }\n\n      userResources.push(userEntity)\n    }\n\n    await this.connection.applyMutation({\n      type: 'full',\n      entities: userResources.map((entity) => ({\n        entity,\n        locationKey: 'hr-user-https://www.hrurl.com/',\n      })),\n    })\n}\n\n")),(0,a.kt)("h2",o({},{id:"custom-processors"}),"Custom Processors"),(0,a.kt)("p",null,"The other possible way of ingesting data into the catalog is through the use of\nlocation reading catalog processors."),(0,a.kt)("p",null,"Processors sit in the middle of the processing loops of the catalog. They are\nresponsible for updating and finalizing unprocessed entities on their way to\nbecoming final, stitched entities. They can also, crucially, emit other entities\nwhile doing so. Those then form branches of the entity tree."),(0,a.kt)("p",null,"Some defining traits of processors:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"You instantiate them using code in your backend, and pass them to the catalog\nbuilder. There's usually only one instance of each type, which then gets\ncalled many times over in parallel for all entities in the catalog."),(0,a.kt)("li",{parentName:"ul"},"Their invocation is driven by the fixed processing loop. All processors are\nunconditionally repeatedly called for all entities. You cannot control this\nbehavior, besides adjusting the frequency of the loop, which then applies\nequally to all processors."),(0,a.kt)("li",{parentName:"ul"},"They cannot control in detail the entities that they emit, the only effective\noperation is upsert on their children. If they stop emitting a certain child,\nthat child becomes marked as an orphan; no deletions are possible."),(0,a.kt)("li",{parentName:"ul"},"Their input is an unprocessed entity, and their output is modifications to\nthat same entity plus possibly some auxiliary data including unprocessed child\nentities.")),(0,a.kt)("h3",o({},{id:"processors-and-the-ingestion-loop"}),"Processors and the Ingestion Loop"),(0,a.kt)("p",null,"The catalog holds a number of registered locations, that were added either by\nsite admins or by individual Backstage users. Their purpose is to reference some\nsort of data that the catalog shall keep itself up to date with. Each location\nhas a ",(0,a.kt)("inlineCode",{parentName:"p"},"type"),", and a ",(0,a.kt)("inlineCode",{parentName:"p"},"target")," that are both strings."),(0,a.kt)("pre",null,(0,a.kt)("code",o({parentName:"pre"},{className:"language-yaml"}),"# Example location\ntype: url\ntarget: https://github.com/backstage/backstage/blob/master/catalog-info.yaml\n")),(0,a.kt)("p",null,"The builtin catalog backend has an ingestion loop that periodically goes through\nall of these registered locations, and pushes them and their resulting output\nthrough the list of ",(0,a.kt)("em",{parentName:"p"},"processors"),"."),(0,a.kt)("p",null,"Processors are classes that the site admin has registered with the catalog at\nstartup. They are at the heart of all catalog logic, and have the ability to\nread the contents of locations, modify in-flight entities that were read out of\na location, perform validation, and more. The catalog comes with a set of\nbuiltin processors, that have the ability to read from a list of well known\nlocation types, to perform the basic processing needs, etc, but more can be\nadded by the organization that adopts Backstage."),(0,a.kt)("p",null,"We will now show the process of creating a new processor and location type,\nwhich enables the ingestion of catalog data from an existing external API."),(0,a.kt)("h3",o({},{id:"deciding-on-the-new-locations"}),"Deciding on the New Locations"),(0,a.kt)("p",null,"The first step is to decide how we want to point at the system that holds our\ndata. Let's assume that it is internally named System-X and can be reached\nthrough HTTP REST calls to its API."),(0,a.kt)("p",null,"Let's decide that our locations shall take the following form:"),(0,a.kt)("pre",null,(0,a.kt)("code",o({parentName:"pre"},{className:"language-yaml"}),"type: system-x\ntarget: http://systemx.services.example.net/api/v2\n")),(0,a.kt)("p",null,"It got its own made-up ",(0,a.kt)("inlineCode",{parentName:"p"},"type"),", and the ",(0,a.kt)("inlineCode",{parentName:"p"},"target")," conveniently points to the\nactual API endpoint to talk to."),(0,a.kt)("p",null,"So now we have to make the catalog aware of such a location so that it can start\nfeeding it into the ingestion loop. For this kind of an integration, you'd\ntypically want to add it to the list of statically always-available locations in\nthe config."),(0,a.kt)("pre",null,(0,a.kt)("code",o({parentName:"pre"},{className:"language-yaml"}),"# In app-config.yaml\ncatalog:\n  locations:\n    - type: system-x\n      target: http://systemx.services.example.net/api/v2\n")),(0,a.kt)("p",null,"If you start up the backend now, it will start to periodically say that it could\nnot find a processor that supports that location. So let's make a processor that\ndoes so!"),(0,a.kt)("h3",o({},{id:"creating-a-catalog-data-reader-processor"}),"Creating a Catalog Data Reader Processor"),(0,a.kt)("p",null,"The recommended way of instantiating the catalog backend classes is to use the\n",(0,a.kt)("inlineCode",{parentName:"p"},"CatalogBuilder"),", as illustrated in the\n",(0,a.kt)("a",o({parentName:"p"},{href:"https://github.com/backstage/backstage/blob/master/packages/backend/src/plugins/catalog.ts"}),"example backend here"),".\nWe will create a new\n",(0,a.kt)("a",o({parentName:"p"},{href:"https://github.com/backstage/backstage/blob/master/plugins/catalog-node/src/api/processor.ts"}),(0,a.kt)("inlineCode",{parentName:"a"},"CatalogProcessor")),"\nsubclass that can be added to this catalog builder."),(0,a.kt)("p",null,"It is up to you where you put the code for this new processor class. For quick\nexperimentation you could place it in your backend package, but we recommend\nputting all extensions like this in a backend plugin package of their own in the\n",(0,a.kt)("inlineCode",{parentName:"p"},"plugins")," folder of your Backstage repo."),(0,a.kt)("p",null,"The class will have this basic structure:"),(0,a.kt)("pre",null,(0,a.kt)("code",o({parentName:"pre"},{className:"language-ts"}),"import { UrlReader } from '@backstage/backend-common';\nimport {\n  processingResult,\n  CatalogProcessor,\n  CatalogProcessorEmit,\n  LocationSpec,\n} from '@backstage/plugin-catalog-node';\n\n// A processor that reads from the fictional System-X\nexport class SystemXReaderProcessor implements CatalogProcessor {\n  constructor(private readonly reader: UrlReader) {}\n\n  getProcessorName(): string {\n    return 'SystemXReaderProcessor';\n  }\n\n  async readLocation(\n    location: LocationSpec,\n    _optional: boolean,\n    emit: CatalogProcessorEmit,\n  ): Promise<boolean> {\n    // Pick a custom location type string. A location will be\n    // registered later with this type.\n    if (location.type !== 'system-x') {\n      return false;\n    }\n\n    try {\n      // Use the builtin reader facility to grab data from the\n      // API. If you prefer, you can just use plain fetch here\n      // (from the node-fetch package), or any other method of\n      // your choosing.\n      const response = await this.reader.readUrl(location.target);\n      const json = JSON.parse((await response.buffer()).toString());\n      // Repeatedly call emit(processingResult.entity(location, <entity>))\n    } catch (error) {\n      const message = `Unable to read ${location.type}, ${error}`;\n      emit(processingResult.generalError(location, message));\n    }\n\n    return true;\n  }\n}\n")),(0,a.kt)("p",null,"The key points to note are:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Make a class that implements ",(0,a.kt)("inlineCode",{parentName:"li"},"CatalogProcessor")),(0,a.kt)("li",{parentName:"ul"},"Only act on location types that you care about, and leave the rest alone by\nreturning ",(0,a.kt)("inlineCode",{parentName:"li"},"false")),(0,a.kt)("li",{parentName:"ul"},"Read the data from the external system in any way you see fit. Use the\nlocation ",(0,a.kt)("inlineCode",{parentName:"li"},"target")," field if you designed it as mentioned above"),(0,a.kt)("li",{parentName:"ul"},"Call ",(0,a.kt)("inlineCode",{parentName:"li"},"emit")," any number of times with the results of that process"),(0,a.kt)("li",{parentName:"ul"},"Finally return ",(0,a.kt)("inlineCode",{parentName:"li"},"true"))),(0,a.kt)("p",null,"You should now be able to add this class to your backend in\n",(0,a.kt)("inlineCode",{parentName:"p"},"packages/backend/src/plugins/catalog.ts"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",o({parentName:"pre"},{className:"language-diff"}),"+import { SystemXReaderProcessor } from '../path/to/class';\n\n export default async function createPlugin(\n   env: PluginEnvironment,\n ): Promise<Router> {\n   const builder = CatalogBuilder.create(env);\n+  builder.addProcessor(new SystemXReaderProcessor(env.reader));\n")),(0,a.kt)("p",null,"Start up the backend - it should now start reading from the previously\nregistered location and you'll see your entities start to appear in Backstage."),(0,a.kt)("h3",o({},{id:"caching-processing-results"}),"Caching processing results"),(0,a.kt)("p",null,"The catalog periodically refreshes entities in the catalog, and in doing so it\ncalls out to external systems to fetch changes. This can be taxing for upstream\nservices and large deployments may get rate limited if too many requests are\nsent. Luckily many external systems provide ETag support to check for changes\nwhich usually doesn't count towards the quota and saves resources both\ninternally and externally."),(0,a.kt)("p",null,"The catalog has built in support for leveraging ETags when refreshing external\nlocations in GitHub. This example aims to demonstrate how to add the same\nbehavior for ",(0,a.kt)("inlineCode",{parentName:"p"},"system-x")," that we implemented earlier."),(0,a.kt)("pre",null,(0,a.kt)("code",o({parentName:"pre"},{className:"language-ts"}),"import { UrlReader } from '@backstage/backend-common';\nimport { Entity } from '@backstage/catalog-model';\nimport {\n  processingResult,\n  CatalogProcessor,\n  CatalogProcessorEmit,\n  CatalogProcessorCache,\n  CatalogProcessorParser,\n  LocationSpec,\n} from '@backstage/plugin-catalog-node';\n\n// It's recommended to always bump the CACHE_KEY version if you make\n// changes to the processor implementation or CacheItem.\nconst CACHE_KEY = 'v1';\n\n// Our cache item contains the ETag used in the upstream request\n// as well as the processing result used when the Etag matches.\n// Bump the CACHE_KEY version if you make any changes to this type.\ntype CacheItem = {\n  etag: string;\n  entity: Entity;\n};\n\nexport class SystemXReaderProcessor implements CatalogProcessor {\n  constructor(private readonly reader: UrlReader) {}\n\n  getProcessorName() {\n    // The processor name must be unique.\n    return 'system-x-processor';\n  }\n\n  async readLocation(\n    location: LocationSpec,\n    _optional: boolean,\n    emit: CatalogProcessorEmit,\n    _parser: CatalogProcessorParser,\n    cache: CatalogProcessorCache,\n  ): Promise<boolean> {\n    // Pick a custom location type string. A location will be\n    // registered later with this type.\n    if (location.type !== 'system-x') {\n      return false;\n    }\n    const cacheItem = await cache.get<CacheItem>(CACHE_KEY);\n    try {\n      // This assumes an URL reader that returns the response together with the ETag.\n      // We send the ETag from the previous run if it exists.\n      // The previous ETag will be set in the headers for the outgoing request and system-x\n      // is going to throw NOT_MODIFIED (HTTP 304) if the ETag matches.\n      const response = await this.reader.readUrl(location.target, {\n        etag: cacheItem?.etag,\n      });\n      if (!response) {\n        // readUrl is currently optional to implement so we have to check if we get a response back.\n        throw new Error(\n          'No URL reader that can parse system-x targets installed',\n        );\n      }\n\n      // ETag is optional in the response but we need it to cache the result.\n      if (!response.etag) {\n        throw new Error(\n          'No ETag returned from system-x, cannot use response for caching',\n        );\n      }\n\n      // For this example the JSON payload is a single entity.\n      const entity: Entity = JSON.parse(response.buffer.toString());\n      emit(processingResult.entity(location, entity));\n\n      // Update the cache with the new ETag and entity used for the next run.\n      await cache.set<CacheItem>(CACHE_KEY, {\n        etag: response.etag,\n        entity,\n      });\n    } catch (error) {\n      if (error.name === 'NotModifiedError' && cacheItem) {\n        // The ETag matches and we have a cached value from the previous run.\n        emit(processingResult.entity(location, cacheItem.entity));\n      }\n      const message = `Unable to read ${location.type}, ${error}`;\n      emit(processingResult.generalError(location, message));\n    }\n\n    return true;\n  }\n}\n")))}h.isMDXComponent=!0},862525:e=>{var t=Object.getOwnPropertySymbols,n=Object.prototype.hasOwnProperty,a=Object.prototype.propertyIsEnumerable;function o(e){if(null==e)throw new TypeError("Object.assign cannot be called with null or undefined");return Object(e)}e.exports=function(){try{if(!Object.assign)return!1;var e=new String("abc");if(e[5]="de","5"===Object.getOwnPropertyNames(e)[0])return!1;for(var t={},n=0;n<10;n++)t["_"+String.fromCharCode(n)]=n;if("0123456789"!==Object.getOwnPropertyNames(t).map((function(e){return t[e]})).join(""))return!1;var a={};return"abcdefghijklmnopqrst".split("").forEach((function(e){a[e]=e})),"abcdefghijklmnopqrst"===Object.keys(Object.assign({},a)).join("")}catch(o){return!1}}()?Object.assign:function(e,r){for(var i,s,l=o(e),c=1;c<arguments.length;c++){for(var p in i=Object(arguments[c]))n.call(i,p)&&(l[p]=i[p]);if(t){s=t(i);for(var u=0;u<s.length;u++)a.call(i,s[u])&&(l[s[u]]=i[s[u]])}}return l}},541535:(e,t,n)=>{var a=n(862525),o=60103,r=60106;var i=60109,s=60110,l=60112;var c=60115,p=60116;if("function"==typeof Symbol&&Symbol.for){var u=Symbol.for;o=u("react.element"),r=u("react.portal"),u("react.fragment"),u("react.strict_mode"),u("react.profiler"),i=u("react.provider"),s=u("react.context"),l=u("react.forward_ref"),u("react.suspense"),c=u("react.memo"),p=u("react.lazy")}var h="function"==typeof Symbol&&Symbol.iterator;function d(e){for(var t="https://reactjs.org/docs/error-decoder.html?invariant="+e,n=1;n<arguments.length;n++)t+="&args[]="+encodeURIComponent(arguments[n]);return"Minified React error #"+e+"; visit "+t+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var m={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},g={};function f(e,t,n){this.props=e,this.context=t,this.refs=g,this.updater=n||m}function y(){}function k(e,t,n){this.props=e,this.context=t,this.refs=g,this.updater=n||m}f.prototype.isReactComponent={},f.prototype.setState=function(e,t){if("object"!=typeof e&&"function"!=typeof e&&null!=e)throw Error(d(85));this.updater.enqueueSetState(this,e,t,"setState")},f.prototype.forceUpdate=function(e){this.updater.enqueueForceUpdate(this,e,"forceUpdate")},y.prototype=f.prototype;var b=k.prototype=new y;b.constructor=k,a(b,f.prototype),b.isPureReactComponent=!0;var v={current:null},w=Object.prototype.hasOwnProperty,N={key:!0,ref:!0,__self:!0,__source:!0};function T(e,t,n){var a,r={},i=null,s=null;if(null!=t)for(a in void 0!==t.ref&&(s=t.ref),void 0!==t.key&&(i=""+t.key),t)w.call(t,a)&&!N.hasOwnProperty(a)&&(r[a]=t[a]);var l=arguments.length-2;if(1===l)r.children=n;else if(1<l){for(var c=Array(l),p=0;p<l;p++)c[p]=arguments[p+2];r.children=c}if(e&&e.defaultProps)for(a in l=e.defaultProps)void 0===r[a]&&(r[a]=l[a]);return{$$typeof:o,type:e,key:i,ref:s,props:r,_owner:v.current}}function C(e){return"object"==typeof e&&null!==e&&e.$$typeof===o}var P=/\/+/g;function E(e,t){return"object"==typeof e&&null!==e&&null!=e.key?function(e){var t={"=":"=0",":":"=2"};return"$"+e.replace(/[=:]/g,(function(e){return t[e]}))}(""+e.key):t.toString(36)}function x(e,t,n,a,i){var s=typeof e;"undefined"!==s&&"boolean"!==s||(e=null);var l=!1;if(null===e)l=!0;else switch(s){case"string":case"number":l=!0;break;case"object":switch(e.$$typeof){case o:case r:l=!0}}if(l)return i=i(l=e),e=""===a?"."+E(l,0):a,Array.isArray(i)?(n="",null!=e&&(n=e.replace(P,"$&/")+"/"),x(i,t,n,"",(function(e){return e}))):null!=i&&(C(i)&&(i=function(e,t){return{$$typeof:o,type:e.type,key:t,ref:e.ref,props:e.props,_owner:e._owner}}(i,n+(!i.key||l&&l.key===i.key?"":(""+i.key).replace(P,"$&/")+"/")+e)),t.push(i)),1;if(l=0,a=""===a?".":a+":",Array.isArray(e))for(var c=0;c<e.length;c++){var p=a+E(s=e[c],c);l+=x(s,t,n,p,i)}else if(p=function(e){return null===e||"object"!=typeof e?null:"function"==typeof(e=h&&e[h]||e["@@iterator"])?e:null}(e),"function"==typeof p)for(e=p.call(e),c=0;!(s=e.next()).done;)l+=x(s=s.value,t,n,p=a+E(s,c++),i);else if("object"===s)throw t=""+e,Error(d(31,"[object Object]"===t?"object with keys {"+Object.keys(e).join(", ")+"}":t));return l}function O(e,t,n){if(null==e)return e;var a=[],o=0;return x(e,a,"","",(function(e){return t.call(n,e,o++)})),a}function S(e){if(-1===e._status){var t=e._result;t=t(),e._status=0,e._result=t,t.then((function(t){0===e._status&&(t=t.default,e._status=1,e._result=t)}),(function(t){0===e._status&&(e._status=2,e._result=t)}))}if(1===e._status)return e._result;throw e._result}var I={current:null};function j(){var e=I.current;if(null===e)throw Error(d(321));return e}},827378:(e,t,n)=>{n(541535)}}]);